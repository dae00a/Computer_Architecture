# Computer_Architecture

This repository organizes Computer Architecture projects of DKU/MSE

4 projects will be uploaded with additional contents referenced by "COMPUTER ORGANIZATION AND DESIGN - The Hardware/Software Interface / RISC-V EDITION"

해당 저장소는 컴퓨터 구조 학부 프로젝트를 정리합니다.

4 개의 프로젝트가 "컴퓨터 구조 및 설계" 서적을 참조하여 추가 내용과 함께 업로드 될 것입니다. 

***

## *Project1* : a simple calculator
### Intro

해당 프로젝트에서는 여러가지 연산을 수행할 수 있는 간단한 계산기를 구현한다. 계산기의 요구사항은 아래와 같다.

- 산술연산 수행(+, -, *, /)
- 비교연산 수행(C)
- 대입연산 수행(M)
- 흐름제어 수행(J, B, H)
- 값을 저장할 수 있는 10개의 레지스터

### Goal

해당 계산기는 프로세서의 명령어 처리 과정을 추상적으로 구현하고 있다. 구현을 통해 현대 컴퓨터 구조의 근간이었던 폰 노이만 구조를 이해하고 명령어가 메모리와 CPU 간에 어떤 과정으로 처리되는 지 알아본다. 이러한 이해를 바탕으로 명령어 집합 아키텍처(ISA)를 이해할 수 있다.

### Concept

ISA(Instruction Set Architecture): 하드웨어와 최하위 소프트웨어 간의 인터페이스이다. 해당 프로그램에서는 입력을 위해 미리 작성된 텍스트 파일의 명령어에 따라 연산을 수행한다. 계산기의 ISA는 다음과 같은 내용을 정의한다.

- 9 개의 연산 종류, 정수형 지원, 2 개의 주소 지정 방식
- 10 개의 범용 레지스터, 1 개의 명령어 레지스터 1 개의 명령어 포인터
- 메모리 파일에서 명령어는 문자열로 구성되어 있으며, 한 줄에는 하나의 명령어가 존재한다.

Von Neumann model : 프로그램 내장 방식, 순차 처리 방식

명령어는 메모리에 한 줄씩 저장되어 있다. 이때, 메모리는 명령어와 데이터 영역이 구분되어 있지 않다. 저장된 명령어를 읽고 해석하는 부분은 제어 장치가 생성하는 제어 신호에 달려있다. 명령어는 한 번에 하나씩 처리된다. 프로그램 카운터는 실행할 명령어가 저장된 주소를 가리킨다. 이때, 프로그램 카운터는 흐름 제어 명령어에 의해 특정 주소를 가리키지 않으면 순차적으로 증가한다.

### Structure

프로그램 내 레지스터와 인터럽트를 위한 플래그를 초기화한다.

실제 메모리와 다르게 특정 크기만큼 나누어져 있지 않고, 파일 내 각 줄을 메모리의 한 물리 주소 공간으로 가정한다. find_address() 사용자 정의 함수를 통해 미리 각 줄의 파일 오프셋(명령어 주소로 가정한다)을 IP 배열에 저장한다.

명령어의 처리는 3 단계로 구분한다.

1. fetch()
    
    IP에 따라 파일 내 명령어를 IR 문자열에 저장한다.
    
2. decode()

    IR 문자열에 저장된 명령어를 opcode에 따라 명령어 타입을 파악하고, 피연산자가 정수형인지, 레지스터 값인지 파악한다.  
    
3. execute()
    
    명령어를 실행한다.
    

각 단계에서 flag (인터럽트 발생)가 1이거나 또는 파일의 끝에 도달하면 프로그램을 종료한다.

지정된 opcode는 ‘+’, ‘-’. ‘*’, ‘/’, M, J, B, C, H이다. 

‘+’는 두 피연산자를 더하고 연산 결과를 R0 레지스터에 저장한다. ‘-’는 첫 번째 피연산자에서 두 번째 피연산자를 빼고 연산 결과를 R0 레지스터에 저장한다. ‘*’는 첫 번째 피연산자와 두 번째 피연산자를 곱한 결과를 R0 레지스터에 저장한다. ‘/’는 첫 번째 피연산자에서 두 번째 피연산자를 나눈 결과를 R0 레지스터에 저장한다. ‘M’은 두 번째 피연산자의 값을 첫 번째 피연산자에 복사한다. ‘J’는 명령어 포인터의 값을 첫 번째 피연산자의 값으로 변경한다. 즉, 다음에 실행될 명령어를 가리킨다. ‘B’는 R0 레지스터의 값이 1인 경우, 명령어 포인터의 값을 첫 번째 피연산자의 값으로 변경한다. ‘C’는 첫 번째 피연산자의 값이 두 번째 피연산자의 값보다 크거나 같으면 R0 레지스터에 0을 저장하고 작으면 1을 저장한다. ‘H’는 프로그램을 종료한다.

### Environment

컴파일 환경: Linux ubuntu / GCC

gcc -Wall -Wextra cal.c -o cal

## *Project2* : single-cycle MIPS
### Intro

해당 프로젝트에서는 간단한 MIPS 시뮬레이터를 구현한다. 
시뮬레이터는 MIPS 아키텍처로 크로스 컴파일된 바이너리 파일의 text segment를 입력으로 한다.
시뮬레이터는 text segment의 명령어를 한 사이클마다 처리하고, 변경된 programmer visible state를 출력한다.
시뮬레이터의 요구사항은 아래와 같다.

- 메모리는 배열로 정의되고, 바이너리 파일의 내용이 저장된다.
- 메모리, 29번 레지스터(SP)와 31번 레지스터(LR)를 제외한 레지스터의 초기값은 0이다. 
29번 레지스터의 초기값은 0x0100:0000이며, 31번 레지스터의 초기값은 0x FFFF:FFFF이다.
- 한 사이클 내에 모든 명령어 수행 단계가 완료된다.
- PC의 초기값은 0이다.
- 각 사이클에서 값이 변한 programmer visible state를 출력한다.
- 입력된 바이너리 파일의 처리가 종료되면 총 명령어의 수와 각 명령어 타입의 수, 메모리 접근 횟수, 분기 횟수, V0레지스터 값을 결과로 출력한다.

### Goal

고전적인 성능 측정 요소인 CPU 시간은 명령어의 수, 클럭 사이클 시간, 명령어 당 클럭 사이클 수에 의해 결정된다. 
클럭 사이클 시간과 명령어 당 클럭 사이클 수는 프로세서의 구현 방법에 따라 결정된다.
반면, 명령어의 수는 컴파일러와 ISA(Instruction Set Architecture)에 의해 결정된다.
단일 사이클 MIPS 시뮬레이터를 구현하며 MIPS ISA에 대해 이해하고, 나아가 프로세서의 구성과 명령어 처리 과정을 이해할 수 있다. 

### Concept

ISA(Instruction Set Architecture)

하드웨어와 최하위 소프트웨어 간의 인터페이스이다.
명령어, 레지스터, 메모리 접근, 입출력 등을 포함하여 정확히 작동하는 기계어 프로그램을 작성하기 위해 알아야 하는 모든 정보를 말한다.

MIPS(Microprocess or without Interlocked Pipeline Stages)

MIPS는 RISC 중 하나이다. MIPS는 아래와 같은 몇 가지 특징을 갖는다.
    
- 모든 명령어는 32bit 이다.
- 32개의 범용 레지스터를 갖고 있으며, $(ZERO)는 0 으로 고정되어 있다.
- 메모리에 접근하는 명령어는 적재, 저장 명령어 뿐이다.
- MIPS core instruction set은 3가지 종류(R, I, J type)로 구성되어 있다.

Big Endian VS Little Endian

컴파일 환경인 인텔 시스템에서는 리틀 엔디언을 사용하는데, 이를 빅 엔디언으로 바꿔주어 메모리 배열에 하위 바이트 부터 저장된 값을 상위 바이트 부터 저장 되도록 한다. Endian에 대한 자세한 설명은 추가 내용에 업로드 될 예정이다. 

Instruction processing

Instruction processing은 data path와 control logic에 의해 수행된다.
data path는 프로세서에서 데이터를 연산하거나 저장하는 유닛으로, PC, Memory, Registers, ALU 등이 있다.
control logic은 제어 신호를 결정하는 유닛으로, 각 신호는 data path 구성 유닛이 어떤 작업을 처리해야 하는지 결정한다.
명령어 처리는 다섯 단계로 진행된다.

1. Instruction Fetch (IF)
2. Instruction Decode (ID)
3. EXecute (EX)
4. MEMory operand fetch (MEM)
5. Write Back result (WB)

### Structure

PC 값이 0xFFFF:FFFF가 아니면 다섯 단계를 계속 순차적으로 수행한다. 
Fetch() 함수에서 PC 값에 해당하는 메모리 주소의 명령어를 가져온다.
Decode() 함수에서 명령어를 해석하여 control signal을 결정한다.
Execute() 함수에서 명령어에 따라 연산을 수행한다.
Memory_Access() 함수에서 control signal에 따라 데이터를 레지스터 혹은 메모리에 저장한다.
WriteBack() 함수에서 control signal에 따라 레지스터에 데이터 저장을 수행한다.


data path는 명령어에 따라서 다음과 같이 동작한다.

JR/JALR을 제외한 R타입 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다. rs와 rt에 해당하는 레지스터를 레지스터 파일로부터 읽는다.
3. 레지스터 값으로부터 funct에 따라 연산을 수행한다.
4. 연산의 결과값이 레지스터 파일의 rd에 해당하는 레지스터에 저장된다.

LW/SW/BEQ/BNE를 제외한 I타입 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다. rs에 해당하는 레지스터를 레지스터 파일로부터 읽는다.
3. rs 레지스터 값과 imm 값으로부터 opcode에 따라 연산을 수행한다.
4. 연산의 결과값이 레지스터 파일의 rt에 해당하는 레지스터에 저장된다.

SW 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다. rs와 rt에 해당하는 레지스터를 레지스터 파일로부터 읽는다.
3. rs 레지스터 값과 imm의 부호 확장한 값의 합을 구한다.
4. 이 합을 통해 메모리의 주소로 접근하여 rt 레지스터 값을 저장한다.

LW 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다. rs와 rt에 해당하는 레지스터를 레지스터 파일로부터 읽는다.
3. rs 레지스터 값과 imm의 부호 확장한 값의 합을 구한다.
4. 이 합을 통해 메모리의 주소로 접근하여 해당 주소에 저장된 값을 읽는다.
5. 메모리에서 읽은 값이 레지스터 파일의 rt에 해당하는 레지스터에 저장된다.

BEQ/BNE 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다. rs와 rt에 해당하는 레지스터를 레지스터 파일로부터 읽는다.
3. 레지스터 값들로 비교 연산을 수행한다. 결괴값과 Branch signal에 따라 분기 목적지 주소로 PC값을 업데이트 한다.

J 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다.
3. Jump signal에 따라 점프 주소로 PC값을 업데이트 한다.

JAL 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다.
3. Jump signal에 따라 점프 주소로 PC값을 업데이트 한다.
4. 31번 레지스터에 PC값의 4 증가한 값을 저장한다.

JR 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다. rs와 rt에 해당하는 레지스터를 레지스터 파일로부터 읽는다.
3. Jump signal에 따라 rs 레지스터 값으로 PC값을 업데이트 한다.

JALR 명령어는 아래와 같은 단계를 수행한다.

1. 명령어를 메모리에서 가져오고 PC값을 4 증가시킨다.
2. 명령어를 해석하고 제어 유닛이 제어 신호를 결정한다. rs와 rt에 해당하는 레지스터를 레지스터 파일로부터 읽는다.
3. Jump signal에 따라 rs 레지스터 값으로 PC값을 업데이트 한다.
4. 31번 레지스터에 PC값을 저장한다.


각 사이클 마다 programmer visible state를 출력한다. 모든 명령어가 처리되면 요구사항을 출력하고 종료한다.

### Environment

컴파일 환경: Linux ubuntu 20.04LTS / gcc

크로스 컴파일 환경: Linux ubuntu 20.04LTS / mips-linux-gnu-gcc