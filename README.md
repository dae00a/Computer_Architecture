# Computer_Architecture

This repository organizes Computer Architecture projects of DKU/MSE

4 projects will be uploaded with additional contents referenced by "COMPUTER ORGANIZATION AND DESIGN - The Hardware/Software Interface / RISC-V EDITION"

해당 저장소는 컴퓨터 구조 학부 프로젝트를 정리합니다.

4 개의 프로젝트가 "컴퓨터 구조 및 설계" 서적을 참조하여 추가 내용과 함께 업로드 될 것입니다. 

***

## *Project1* : a simple calculator
### Intro

해당 프로젝트에서는 여러가지 연산을 수행할 수 있는 간단한 계산기를 구현한다. 계산기의 요구사항은 아래와 같다.

- 산술연산 수행(+, -, *, /)
- 비교연산 수행(C)
- 대입연산 수행(M)
- 흐름제어 수행(J, B, H)
- 값을 저장할 수 있는 10개의 레지스터

### Goal

해당 계산기는 프로세서의 명령어 처리 과정을 추상적으로 구현하고 있다. 구현을 통해 현대 컴퓨터 구조의 근간이었던 폰 노이만 구조를 이해하고 명령어가 메모리와 CPU 간에 어떤 과정으로 처리되는 지 알아본다. 이러한 이해를 바탕으로 명령어 집합 아키텍처(ISA)를 이해할 수 있다.

### Concept

ISA(Instruction Set Architecture): 하드웨어와 최하위 소프트웨어 간의 인터페이스이다. 해당 프로그램에서는 입력을 위해 미리 작성된 텍스트 파일의 명령어에 따라 연산을 수행한다. 계산기의 ISA는 다음과 같은 내용을 정의한다.

- 9 개의 연산 종류, 정수형 지원, 2 개의 주소 지정 방식
- 10 개의 범용 레지스터, 1 개의 명령어 레지스터 1 개의 명령어 포인터
- 메모리 파일에서 명령어는 문자열로 구성되어 있으며, 한 줄에는 하나의 명령어가 존재한다.

Von Neumann model : 프로그램 내장 방식, 순차 처리 방식

명령어는 메모리에 한 줄씩 저장되어 있다. 이때, 메모리는 명령어와 데이터 영역이 구분되어 있지 않다. 저장된 명령어를 읽고 해석하는 부분은 제어 장치가 생성하는 제어 신호에 달려있다. 명령어는 한 번에 하나씩 처리된다. 프로그램 카운터는 실행할 명령어가 저장된 주소를 가리킨다. 이때, 프로그램 카운터는 흐름 제어 명령어에 의해 특정 주소를 가리키지 않으면 순차적으로 증가한다.

### Structure

프로그램 내 레지스터와 인터럽트를 위한 플래그를 초기화한다.

실제 메모리와 다르게 특정 크기만큼 나누어져 있지 않고, 파일 내 각 줄을 메모리의 한 물리 주소 공간으로 가정한다. find_address() 사용자 정의 함수를 통해 미리 각 줄의 파일 오프셋(명령어 주소로 가정한다)을 IP 배열에 저장한다.

명령어의 처리는 3 단계로 구분한다.

1. fetch()
    
    IP에 따라 파일 내 명령어를 IR 문자열에 저장한다.
    
2. decode()

    IR 문자열에 저장된 명령어를 opcode에 따라 명령어 타입을 파악하고, 피연산자가 정수형인지, 레지스터 값인지 파악한다.  
    
3. execute()
    
    명령어를 실행한다.
    

각 단계에서 flag (인터럽트 발생)가 1이거나 또는 파일의 끝에 도달하면 프로그램을 종료한다.

지정된 opcode는 ‘+’, ‘-’. ‘*’, ‘/’, M, J, B, C, H이다. 

‘+’는 두 피연산자를 더하고 연산 결과를 R0 레지스터에 저장한다. ‘-’는 첫 번째 피연산자에서 두 번째 피연산자를 빼고 연산 결과를 R0 레지스터에 저장한다. ‘*’는 첫 번째 피연산자와 두 번째 피연산자를 곱한 결과를 R0 레지스터에 저장한다. ‘/’는 첫 번째 피연산자에서 두 번째 피연산자를 나눈 결과를 R0 레지스터에 저장한다. ‘M’은 두 번째 피연산자의 값을 첫 번째 피연산자에 복사한다. ‘J’는 명령어 포인터의 값을 첫 번째 피연산자의 값으로 변경한다. 즉, 다음에 실행될 명령어를 가리킨다. ‘B’는 R0 레지스터의 값이 1인 경우, 명령어 포인터의 값을 첫 번째 피연산자의 값으로 변경한다. ‘C’는 첫 번째 피연산자의 값이 두 번째 피연산자의 값보다 크거나 같으면 R0 레지스터에 0을 저장하고 작으면 1을 저장한다. ‘H’는 프로그램을 종료한다.

### Environment

컴파일 환경: Linux ubuntu / GCC

gcc -Wall -Wextra cal.c -o cal
